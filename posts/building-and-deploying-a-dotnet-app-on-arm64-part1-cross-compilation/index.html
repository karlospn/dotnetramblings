<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Building and deploying a .NET 8 App on an ARM64 processor using Azure Pipelines and AWS ECS Fargate. Part 1: How to build multi-platform images :: my tech ramblings — A blog for writing about my techie ramblings</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="This is a two-part series post.
Part 1: Key concepts about how to build multi-platform images. Part 2: A practical example of how to build a container image targeting an ARM64 processor using Azure Pipelines and how to deploy it on AWS ECS Fargate. It will also include a quick benchmark to compare the performance of the application running on an ARM64 Fargate container against the same app using an AMD64 Fargate container."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://www.mytechramblings.com/posts/building-and-deploying-a-dotnet-app-on-arm64-part1-cross-compilation/" />





<link rel="stylesheet" href="https://www.mytechramblings.com/assets/style.css">


<link rel="stylesheet" href="https://www.mytechramblings.com/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://www.mytechramblings.com/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="https://www.mytechramblings.com/img/favicon.png">


<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Building and deploying a .NET 8 App on an ARM64 processor using Azure Pipelines and AWS ECS Fargate. Part 1: How to build multi-platform images"/>
<meta name="twitter:description" content="In this two-part series, I’m going to show you how to build and deploy a .NET 8 app container image that targets an ARM64 processor. In part 1, I’ll be discussing some key concepts that you should know about how to build .NET multi-platform images."/>



<meta property="og:title" content="Building and deploying a .NET 8 App on an ARM64 processor using Azure Pipelines and AWS ECS Fargate. Part 1: How to build multi-platform images" />
<meta property="og:description" content="In this two-part series, I’m going to show you how to build and deploy a .NET 8 app container image that targets an ARM64 processor. In part 1, I’ll be discussing some key concepts that you should know about how to build .NET multi-platform images." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mytechramblings.com/posts/building-and-deploying-a-dotnet-app-on-arm64-part1-cross-compilation/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T22:00:30+01:00" />
<meta property="article:modified_time" content="2024-03-12T22:00:30+01:00" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="https://www.mytechramblings.com/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">my tech ramblings</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://www.dotnetramblings.com">.NET News</a></li>
        
      
        
          <li><a href="/about">About</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://www.dotnetramblings.com">.NET News</a></li>
      
    
      
        <li><a href="/about">About</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title"><a href="https://www.mytechramblings.com/posts/building-and-deploying-a-dotnet-app-on-arm64-part1-cross-compilation/">Building and deploying a .NET 8 App on an ARM64 processor using Azure Pipelines and AWS ECS Fargate. Part 1: How to build multi-platform images</a></h1>
    <div class="post-meta">
      
        <span class="post-date">
          2024-03-12
        </span>

        
          
            



          
        
      

      
      
        <span class="post-read-time">— 12 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="https://www.mytechramblings.com/tags/dotnet/">dotnet</a>&nbsp;
        
          #<a href="https://www.mytechramblings.com/tags/containers/">containers</a>&nbsp;
        
          #<a href="https://www.mytechramblings.com/tags/azure/">azure</a>&nbsp;
        
          #<a href="https://www.mytechramblings.com/tags/aws/">aws</a>&nbsp;
        
          #<a href="https://www.mytechramblings.com/tags/devops/">devops</a>&nbsp;
        
          #<a href="https://www.mytechramblings.com/tags/arm64/">arm64</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      
      <blockquote>
<p>This is a two-part series post.</p>
<ul>
<li><strong>Part 1</strong>: Key concepts about how to build multi-platform images.</li>
<li><strong>Part 2</strong>: A practical example of how to build a container image targeting an ARM64 processor using Azure Pipelines and how to deploy it on AWS ECS Fargate. <br>
It will also include a quick benchmark to compare the performance of the application running on an ARM64 Fargate container against the same app using an AMD64 Fargate container.</li>
</ul>
</blockquote>
<p>If you examine the enhancements in the latest .NET versions, you&rsquo;ll notice that each one of them brings quite a few improvements for ARM64 processors. The argument for using ARM64 processors over AMD64 is that ARM64 processors are cheaper, more efficient, and can reduce the carbon footprint.</p>
<p>But, how easy is it to work with ARM64 in .NET? Let&rsquo;s conduct a little test in this post. <br>
Let&rsquo;s explore the entire process of building and deploying a .NET 8 API to an ARM64 host.</p>
<p>My machine has an AMD64 processor, and I want to create a container image that targets an ARM64 processor. This is the most common scenario when attempting to build your application on most CI providers, like Azure Pipelines, GitHub Actions, or GitLab CI. They don&rsquo;t offer hosted ARM64 runners.</p>
<p>Obviously, one option is to run your own builder instances that match the target architecture, but that&rsquo;s my least favorite option. You have to create your own VM instances somewhere, set them up, configure them to run with your selected CI runner, maintain them, etc, etc.</p>
<p>This option might be your go-to solution, especially when you&rsquo;re working in a large enterprise, where dozens and dozens of builds are executed every day. Having your own CI runner gives you the ability to set it up according to your specific software and hardware needs. Also, in an environment where hundreds of builds are triggered every hour, it is cheaper to use a self-hosted runner instead of the ones offered by the CI provider itself.</p>
<p>Obviously, I could tell you that if you want to build an image targeting an ARM64 processor, you just need to create an ARM64 machine, accommodate the Dockerfile of your .NET 8 API to target the ARM64 architecture, as shown in the next code snippet, execute a simple <code>docker build</code> command in the newly created machine, and you&rsquo;re done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/sdk:8.0-jammy-arm64v8 AS build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . ./</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./Arm64Testing.WebApi.csproj&#34; \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#ae81ff">runtime linux-arm64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; \</span>
</span></span><span style="display:flex;"><span>    -<span style="color:#ae81ff">c Release \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#ae81ff">runtime linux-arm64 \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#66d9ef">no</span>-<span style="color:#ae81ff">restore</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; \</span>
</span></span><span style="display:flex;"><span>    -<span style="color:#ae81ff">c Release \</span>
</span></span><span style="display:flex;"><span>    -<span style="color:#ae81ff">o /app/publish \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#ae81ff">runtime linux-arm64 \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#66d9ef">no</span>-<span style="color:#ae81ff">restore \</span>
</span></span><span style="display:flex;"><span>    --<span style="color:#66d9ef">no</span>-<span style="color:#ae81ff">build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0-jammy-arm64v8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=build /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>But that would be too easy, right? For the sake of this post, let&rsquo;s keep this option off the table.</p>
<p>Imagine you want to <strong>create a container image that targets an ARM64 processor using an AMD64 processor</strong>. A very common scenario for this use case would be attempting to create a container image using a hosted runner in Azure DevOps or GitHub Actions, because neither of them supports ARM64 hosted runners.</p>
<p>I know that GitHub Actions ARM64 runners are a thing nowadays, but they&rsquo;re still in a private beta state.</p>
<p>In part 1 of this post, <strong>we will explore the current options for building a .NET 8 API container image that targets an ARM64 processor using an AMD64 processor</strong>.</p>
<h1 id="docker-buildx-command"><strong>docker buildx command</strong></h1>
<p>In order to build multi-platform container images, we need to make use of the <code>docker buildx</code> command. <code>Buildx</code> is a Docker CLI plugin that extends the docker build command with the full support of the features provided by Moby BuildKit builder toolkit.</p>
<p>By default, a build executed with <code>buildx</code> will build an image for the architecture that matches the host machine. This way, you get an image that runs on the same machine you are working on. In order to build it for a different architecture, you need to the <code>--platform</code> flag, e.g. <code>--platform=linux/arm64</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker buildx build --platform<span style="color:#f92672">=</span>linux/arm64 -t my-api .
</span></span></code></pre></div><p>When you want to create a multi-platform image you don&rsquo;t have to specifically use the <code>buildx</code> syntax. <code>Buildx</code> is a drop-in replacement for the legacy build client used in earlier versions of Docker Engine and Docker Desktop.</p>
<p>In newer versions of Docker Desktop and Docker Engine, <strong>you&rsquo;re using buildx by default when you invoke the docker build command</strong>, so every time you&rsquo;re using the <code>docker build</code> command, in fact you&rsquo;re using the <code>buildx</code> command.</p>
<h1 id="net-images"><strong>.NET images</strong></h1>
<p>.NET 8 images support multiple platforms, which means that a single image may contain variants for different architectures. <br>
When you run an image with multi-platform support, Docker automatically selects the image that matches your OS and architecture.</p>
<p>The following code snippet demonstrates how the .NET 8 SDK and runtime images contain a multi-platform tag image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker manifest inspect mcr.microsoft.com/dotnet/sdk:8.0 | grep architecture
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm64&#34;</span>,
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker manifest inspect mcr.microsoft.com/dotnet/runtime:8.0 | grep architecture
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm64&#34;</span>,
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker manifest inspect mcr.microsoft.com/dotnet/runtime-deps:8.0 | grep architecture
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;arm64&#34;</span>,
</span></span></code></pre></div><p>When running any of these images on an  <code>AMD64</code> processor, the <code>AMD64</code> variant will be pulled and run, and exactly the same happens with <code>ARM64</code>.</p>
<p>When you want to run the <code>build</code> command with a specific architecture that is not your host machine architecture, you can use the <code>--platform</code> attribute, e.g. <code>linux/amd64</code>, <code>linux/arm64</code>, etc.</p>
<p>Let me provide you with a practical example to demonstrate how it works. The following Dockerfile is the default one that Visual Studio creates when you create a new .NET 8 API.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>Let&rsquo;s begin by simply building the image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build -t my-api .
</span></span><span style="display:flex;"><span>Building 16.8s <span style="color:#f92672">(</span>18/18<span style="color:#f92672">)</span> FINISHED
</span></span><span style="display:flex;"><span>$ docker inspect my-api -f <span style="color:#e6db74">&#34;{{.Os}}/{{.Architecture}}&#34;</span>
</span></span><span style="display:flex;"><span>linux/amd64
</span></span></code></pre></div><p>Obviously, my machine has an AMD64 processor, so if we inspect it, we can see that the image targets a <code>linux/amd64</code> architecture.</p>
<p>Now, let&rsquo;s specify another platform using the <code>--platform</code> attribute.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build --platform<span style="color:#f92672">=</span>linux/arm64 -t my-api .
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Building 82.1s <span style="color:#f92672">(</span>18/18<span style="color:#f92672">)</span> FINISHED
</span></span><span style="display:flex;"><span>$ docker inspect my-api -f <span style="color:#e6db74">&#34;{{.Os}}/{{.Architecture}}&#34;</span>
</span></span><span style="display:flex;"><span>linux/arm64
</span></span></code></pre></div><p>It takes considerably more time to build the image, but we end up with an ARM64 image.</p>
<p>The interesting part here is that we haven&rsquo;t changed anything at all in the Dockerfile. That&rsquo;s because the .NET 8 images are using a multi-platform tag image. If we don&rsquo;t specify the <code>--platform</code> attribute, it uses an image that targets the host machine architecture. If we specify the <code>--platform</code> attribute, then it uses the image that targets the architecture we have specified.</p>
<p>The .NET team also publishes architecture-specific images, such as <code>mcr.microsoft.com/dotnet/aspnet:8.0-jammy-arm64v8</code>. Those images are specific to a given architecture. If we&rsquo;re determined to use a specific architecture and there is no need to create images for multiple architectures, then you can use them.</p>
<p>Let&rsquo;s modify the above Dockerfile to use the <code>arm64</code> architecture-specific images.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0-jammy-arm64v8 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/sdk:8.0-jammy-arm64v8 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>And try to build it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build -t my-api .
</span></span><span style="display:flex;"><span>Building 86.8s <span style="color:#f92672">(</span>18/18<span style="color:#f92672">)</span> FINISHED
</span></span><span style="display:flex;"><span>$ docker inspect my-api -f <span style="color:#e6db74">&#34;{{.Os}}/{{.Architecture}}&#34;</span>
</span></span><span style="display:flex;"><span>linux/arm64
</span></span></code></pre></div><p>As you can see, an arm64 image also gets created. With this approach using the <code>--platform</code> attribute makes no sense, because we&rsquo;re specifically building an image that targets an ARM64 architecture.</p>
<h1 id="multi-platform-image-strategies"><strong>Multi-platform image strategies</strong></h1>
<p>Now that we have some context about what the <code>buildx</code> command is used for and what the .NET multi-platform images are, let&rsquo;s get down to business. You can build multi-platform images using three different strategies:</p>
<ul>
<li>Building the image on a machine with the desired target architecture. In simple terms, if you want to build an ARM64 container image, then build it on an ARM64 machine.</li>
<li>Using emulation.</li>
<li>Using a stage in your Dockerfile to <code>cross-compile</code> to different architectures.</li>
</ul>
<h2 id="1-emulation"><strong>1. Emulation</strong></h2>
<p>The emulation software used for building multi-platform images is named <a href="https://www.qemu.org/">QEMU</a>.</p>
<p>If you&rsquo;re using Docker Desktop to create your images, then it supports QEMU out of the box. If you&rsquo;re using only Docker Engine, you&rsquo;ll need to install it using something like <a href="https://github.com/multiarch/qemu-user-static">qemu-user-static</a>.</p>
<p>Emulation is the easiest option of the three available, because it requires no changes at all to your Dockerfile. The BuildKit automatically detects the secondary architectures that are available and when BuildKit needs to run a binary for a different architecture, it automatically loads it.</p>
<p>You can use the <code>docker buildx ls</code> command to see what emulators are installed on your machine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker buildx ls
</span></span><span style="display:flex;"><span>NAME/NODE       DRIVER/ENDPOINT STATUS  BUILDKIT PLATFORMS
</span></span><span style="display:flex;"><span>default *       docker
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">\_</span> default       default         running v0.12.5  linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/arm/v7, linux/arm/v6
</span></span></code></pre></div><p>If you see different platforms listed (like linux/arm64, linux/riscv64, etc.), and you&rsquo;re building an image for a platform that&rsquo;s different from your host platform, then QEMU is being used to emulate the target platform.</p>
<p>Emulation with QEMU is much more slower than native builds and requires much more processing power. Moreover, QEMU doesn&rsquo;t quite work well with .NET.</p>
<p>Remember the previous section when we built a couple of ARM64 images using the <code>--platform</code> attribute? We were using emulation to build them.</p>
<p>On my machine, bulding a container with QEMU that contained a simple .NET 8 &ldquo;Hello World&rdquo; API was taking more than 80 seconds, and the CPU was peaking near 90%. Now image how long will it take to build real-world applications using emulation  (if they work at all, because as I said before, QEMU and .NET don&rsquo;t quite gel together).</p>
<p>A much better option for building .NET apps is to use cross-compilation instead of emulation.</p>
<h1 id="2-cross-compilation"><strong>2. Cross-Compilation</strong></h1>
<p>Emulation is only used when building multi-architecture images or running containers for a different architecture than your host machine. If you&rsquo;re building an image for the same architecture as your host machine, Docker will just use the native OS and CPU architecture, and QEMU won&rsquo;t be involved.</p>
<p>That&rsquo;s where cross-compilation comes to play. Using cross-compilation means leveraging the capabilities of a compiler to build for multiple platforms, without the need for emulation. The idea behind it is to use a multi-stage build and in the build stage compile your code for the target architecture, and in the run stage configure the runtime to be exported to the final image.</p>
<p>This approach involves using a few pre-defined build arguments that you have access to in your Docker builds. For .NET we&rsquo;re going to use the <code>BUILDPLATFORM</code> and the <code>TARGETARCH</code> arguments. These build arguments reflect the values you pass to the <code>--platform</code> flag.</p>
<p>For example, if you invoke <code>docker build</code> with <code>--platform=linux/arm64</code>, then the build arguments resolve to:</p>
<ul>
<li>BUILDPLATFORM=<code>linux/amd64</code> (my host machine architecture)</li>
<li>TARGETARCH=<code>arm64</code></li>
</ul>
<p>Let&rsquo;s modify the Dockerfile from the previous section to use cross-compilation. This is how the Dockerfile from the previous section looked:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>The first thing you&rsquo;ll need to do is use the <code>BUILDPLATFORM</code> argument to pin the builder to use the host native architecture as the build platform. This is only to prevent emulation. That translates to adding <code>--platform=$BUILDPLATFORM</code> to the <code>FROM</code> instruction for the initial build stage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM --platform=$BUILDPLATFORM  mcr.microsoft.com/dotnet/sdk:8.0 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM  --platform=$BUILDPLATFORM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>Next, add the <code>ARG TARGETARCH</code> instructions for the build stage, making the <code>TARGETARCH</code> build arguments available to the commands in this stage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM --platform=$BUILDPLATFORM  mcr.microsoft.com/dotnet/sdk:8.0 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG TARGETARCH</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34; </span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM  --platform=$BUILDPLATFORM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG TARGETARCH</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>Finally modify the <code>dotnet restore</code>, <code>dotnet build</code> and <code>dotnet publish</code> commands so they generate the application binaries for the target architecture (in our case <code>arm64</code>).</p>
<p>To accomplish this, we&rsquo;re going to use the <code>--arch</code> attribute. This attribute can be used in all three commands (<code>dotnet restore</code>, <code>dotnet build</code> and <code>dotnet publish</code>) and it is used to set the Runtime Identifier (RID).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#ae81ff">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">USER app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8080</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">EXPOSE 8081</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM --platform=$BUILDPLATFORM  mcr.microsoft.com/dotnet/sdk:8.0 AS build</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG TARGETARCH</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /src</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY [&#34;Arm64Testing.WebApi.csproj&#34;, &#34;.&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet restore &#34;./././Arm64Testing.WebApi.csproj&#34; --arch $TARGETARCH</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY . .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR &#34;/src/.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet build &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/build --arch $TARGETARCH</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM  --platform=$BUILDPLATFORM build AS publish</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG BUILD_CONFIGURATION=Release</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ARG TARGETARCH</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">RUN dotnet publish &#34;./Arm64Testing.WebApi.csproj&#34; -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false --arch $TARGETARCH</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">FROM base AS final</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">WORKDIR /app</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">COPY --from=publish /app/publish .</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">ENTRYPOINT [&#34;dotnet&#34;, &#34;Arm64Testing.WebApi.dll&#34;]</span>
</span></span></code></pre></div><p>And we&rsquo;re done, let&rsquo;s just give it a try.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build --platform<span style="color:#f92672">=</span>linux/arm64 -t my-api .
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Building 17.7s <span style="color:#f92672">(</span>18/18<span style="color:#f92672">)</span> FINISHED
</span></span><span style="display:flex;"><span>$ docker inspect my-api -f <span style="color:#e6db74">&#34;{{.Os}}/{{.Architecture}}&#34;</span>
</span></span><span style="display:flex;"><span>linux/arm64
</span></span></code></pre></div><p>Using cross-compilation, we&rsquo;ve reduced the build time of a simple .NET 8 API container image that targets an ARM64 processor on my AMD64 machine from over 80 seconds to 17 seconds, and the CPU usage from nearly 90% to no more than 20%.</p>
<p>However, it&rsquo;s worth noting that while this &ldquo;Hello World&rdquo; .NET 8 API worked well with QEMU, more complex applications may encounter some errors when using emulation.</p>
<p>In part 2 of this blog post, we will attempt to perform an end-to-end process. We will build a .NET 8 API, containerize the app targeting an ARM64 processor using Azure Pipelines, and finally deploy it on AWS ECS Fargate. <br>
Additionally, we will conduct a quick benchmark to compare the performance of the application running on an ARM64 Fargate container against the same app using an AMD64 Fargate container.</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h">Read other posts</span>
            <hr />
          </div>
          <div class="pagination__buttons">
            
            
              <span class="button next">
                <a href="https://www.mytechramblings.com/posts/how-to-update-an-azure-api-mgmt-api-that-uses-a-remote-openapi-using-terraform/">
                  <span class="button__text">How to update an Azure API Management API that is configured with a remote OpenApi definition using Terraform</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    


    
      
        

      
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span>
        <span>Theme created by <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="https://www.mytechramblings.com/assets/main.js"></script>
<script src="https://www.mytechramblings.com/assets/prism.js"></script>
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('carlospons', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Donate',
    'floating-chat.donateButton.background-color': '#ff5f5f',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>

      
    </div>

    
      
<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-170300931-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
    
  </body>
</html>
